server:
  port: 8085

spring:
  main:
    #解决bean重复定义的问题。设置为true时，后定义的bean会覆盖之前定义的相同名称的bean
    allow-bean-definition-overriding: true
  #4.0 配置是shardingsphere 3.0是shardingjdbc
  shardingsphere:
    #参数配置，显示sql
    props:
      sql:
        show: true
    #配置数据源
    datasource:
      #给每个数据源取别名，下面的ds0,ds1任意取名字
      names: ds0,ds1
      #给master-ds1每个数据源配置数据库连接信息
      ds0:
        #配置druid数据源
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://192.168.23.10:3306/zyc_sharding_db?useUnicode=true&characterEncoding=utf8&tinyInt1isBit=false&serverTimezone=GMT%2B8&useSSL=false
        username: root
        password: 111111
        maxPoolSize: 100
        minPoolSize: 5
      #配置ds1-slave
      ds1:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://192.168.23.11:3306/zyc_sharding_db?useUnicode=true&characterEncoding=utf8&tinyInt1isBit=false&serverTimezone=GMT%2B8&useSSL=false
        username: root
        password: 111111
        maxPoolSize: 100
        minPoolSize: 5

    #配置默认数据源ds1; ***如果不设置新增的时候就会报错
    sharding:
      #配置数据源，主要用于写，注意一定要做读写分离,  注意：如果不配置， 那么就会把三个节点都当做从slave节点，新增，修改和删除都会报错
      default-data-source-name: ds0
      #配置分表的规则
      tables:
        #user_order 逻辑表名
        user_order:
          actualDataNodes: ds0.user_order_$->{2021..2022}${(1..3).collect{t -> t.toString().padLeft(2, '0')}}
          keyGenerator:
            # 主键采用雪花算法 可使用用户自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID
            column: orderId
            type: SNOWFLAKE
          #拆分库策略，也就是什么样子的数据放入放到哪个数据库中
          database-strategy:
            inline:
              shardingColumn: orderId #分表字段 （分片键）
              algorithm-expression: ds$->{orderId % 2} #分片算法表达式
          table-strategy:
            inline:
              sharding-column: yearMonth #分表字段 （分片键）
              algorithm-expression: user_order_$->{yearMonth} #分片算法表达式
